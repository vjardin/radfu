[name]
radfu - Renesas RA Device Firmware Update tool

[description]
radfu is a flash programming tool for Renesas RA microcontroller series.
It communicates with the built-in ROM bootloader to perform firmware update
operations via USB or UART/SCI interfaces.

The tool implements the Renesas RA Standard Boot Firmware protocol and
supports the following MCU series:

.TP
.B RA4 Series (Cortex-M4/M23)
Tested and fully supported. Uses boot code 0xC3.

.TP
.B RA2 Series (Cortex-M23)
Should work, uses boot code 0xC3.

.TP
.B RA6 Series (Cortex-M33)
Should work, uses boot code 0xC6.

[entering dfu mode]
To program an RA microcontroller, you must first enter DFU (Device Firmware
Update) mode by activating the ROM bootloader.

.SS Hardware Configuration
The MD pin controls the boot mode. When MD is LOW at reset, the MCU enters
the ROM bootloader instead of running user code.

.SS EK-RA4M2 Development Board
On the EK-RA4M2 evaluation board, jumper J16 controls the MD pin (P201):

.TP
.B J16 Open (default)
Single-Chip Mode - Normal operation, runs user application.

.TP
.B J16 Installed
SCI/USB Boot Mode - ROM bootloader active, ready for programming.

.SS Entering DFU Mode on EK-RA4M2
.IP 1. 4
Install jumper on J16 (shorts P201/MD to GND)
.IP 2.
Connect USB cable to Device USB port (J11) - not the Debug USB
.IP 3.
Press RESET button
.IP 4.
MCU enters ROM bootloader and appears as USB device

.SS Returning to Normal Mode
.IP 1. 4
Remove jumper from J16
.IP 2.
Press RESET button
.IP 3.
MCU runs your application

[commands]
.TP
.B info
Query and display device information including MCU signature, firmware
version, and memory area layout. This command does not modify the device.

.TP
.B read <file>
Read flash memory contents to a file. Use \fB-a\fR to specify the
start address and \fB-s\fR for the size to read. If size is omitted, reads
the entire flash area. Use \fB-F\fR to specify the output format (auto-detected
by default from extension). Supported formats: binary (.bin), Intel HEX (.hex),
and Motorola S-record (.srec, .s19, .s37).

.TP
.B write <file>[:<addr>] [<file>:<addr>] ...
Write one or more firmware files to flash memory. The flash area is automatically
erased before writing. Supports binary, Intel HEX, and Motorola S-record formats.

For single file mode, use \fB-a\fR to specify the start address (if omitted
and the file contains address information, the embedded address is used).

For multi-file mode, append the address after a colon (e.g., app.bin:0x10000).
Files without an address use the embedded address (for HEX/S-record) or 0x0.
Use \fB-f\fR to specify the input format and \fB-v\fR to verify after writing.

.nf
    radfu write boot.bin:0x0 app.bin:0x10000 data.bin:0x08000000
    radfu write -v firmware.hex config.bin:0x08000000
.fi

.TP
.B verify <file>
Verify flash memory contents against a firmware file. Supports binary, Intel HEX,
and Motorola S-record formats. Use \fB-f\fR to specify the format (auto-detected
by default from extension). Use \fB-a\fR to specify the start address (if omitted
and the file contains address information, the embedded address is used). Use
\fB-s\fR to specify the size. If size is omitted, verifies the file size.
Reports the first mismatch if any.

.TP
.B erase
Erase flash memory sectors. Use \fB-a\fR and \fB-s\fR to specify the address
range. Use \fB-e\fR (--erase-all) to perform a total area erasure.

.TP
.B blank-check
Check if a flash memory region is erased (all bytes are 0xFF). Use \fB-a\fR
to specify the start address and \fB-s\fR to specify the size. Reports the
first non-blank byte if the check fails.

.TP
.B config-read
Read and display the config area contents. Shows a status summary indicating
whether the area is factory default (all 0xFF) or has been configured, then
displays parsed block protection settings (BPS, PBPS, FSPR), followed by a
hex dump of the raw contents. Block protection bits indicate which flash
blocks are protected from programming/erasure. A value of 0 means protected,
1 means unprotected. PBPS (Permanent Block Protection) cannot be reversed
once set to 0.

.TP
.B backup <file>
Backup all readable flash areas to a single file. Reads code flash, data flash,
and config area and saves them to an Intel HEX or Motorola S-record file.

Only Intel HEX (.hex) and S-record (.srec, .s19) formats are supported because
they can represent non-contiguous memory regions (code flash at 0x0, data flash
at 0x08000000). Binary format is not supported for backup.

Use \fB-F\fR to explicitly specify the output format, or let radfu auto-detect
from the file extension.

.nf
    radfu backup device_backup.hex        # Intel HEX format
    radfu backup device_backup.srec       # S-record format
    radfu backup -F srec backup.dat       # Force S-record format
.fi

.TP
.B restore <file>
Restore flash from a backup file. Performs a full chip erase (code flash and
data flash), then writes all data from the backup file to flash.

The backup file must be in Intel HEX or Motorola S-record format with embedded
address information. Use \fB-v\fR to verify each region after writing.

.B WARNING:
This command erases all code and data flash before writing. Make sure you have
a valid backup before using this command.

.nf
    radfu restore device_backup.hex       # Restore from Intel HEX
    radfu restore -v device_backup.hex    # Restore with verification
    radfu restore device_backup.srec      # Restore from S-record
.fi

.TP
.B raw <cmd> [data...]
Send a raw bootloader command for protocol exploration and debugging. The command
byte and optional data bytes are specified as hexadecimal values (with or without
0x prefix). Displays detailed TX/RX packet analysis including field-by-field
breakdown, checksum verification, and interpretation of known response fields.

This command is useful for:
.IP \(bu 4
Exploring undocumented bootloader commands
.IP \(bu
Debugging protocol issues
.IP \(bu
Security research and reverse engineering
.IP \(bu
Testing device behavior with specific command sequences

.SS Output Format
The command displays:
.IP \(bu 4
Raw hexdump of transmitted and received packets
.IP \(bu
Field analysis: SOH/SOD, length, command/response code, data, checksum, ETX
.IP \(bu
Interpretation of known fields (addresses, DLM states, error codes, etc.)
.IP \(bu
Checksum validation status

.SS Examples
.nf
radfu raw 0x3A                    # Signature request (device info)
radfu raw 0x3B 0x00               # Area information for area 0
radfu raw 0x2C                    # DLM state request
radfu raw 0x15 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0xFF  # Read 256 bytes from 0x0
radfu raw 0x99                    # Test unknown command (returns error)
.fi

[id authentication]
Some RA devices have ID code protection enabled. To access protected devices,
you must provide the correct 16-byte ID code using the \fB-i\fR option.

The ID code must be specified as 32 hexadecimal characters (with optional
0x prefix):

.nf
    radfu info -i 0102030405060708090A0B0C0D0E0F10
.fi

.SS ALeRASE Magic ID
The special ID code "ALeRASE" (followed by 0xFF padding) triggers a total
area erasure on devices that support it. Use \fB-e\fR (--erase-all) as a
shortcut:

.nf
    radfu erase -e
.fi

[baud rate]
When using UART/SCI (not USB), the baud rate can be configured with \fB-b\fR.
Supported rates depend on the MCU's SCI clock:

.TP
.B RA4 Series (24 MHz SCI)
9600, 115200, 230400, 460800, 921600, 1000000, 1500000

.TP
.B RA6 Series (60 MHz SCI)
9600 to 4000000 (including 2000000, 3000000, 3500000)

USB communication is not affected by baud rate settings.

[input formats]
The \fBwrite\fR and \fBverify\fR commands support multiple firmware file formats.
Use \fB-f\fR to explicitly specify the format, or let radfu auto-detect from the
file extension.

.SS Supported Formats
.TP
.B binary (bin)
Raw binary data. Extensions: .bin, .dat, or any unknown extension.
No address information; use \fB-a\fR to specify the target address.

.TP
.B ihex (Intel HEX)
Intel HEX format with embedded address records. Extensions: .hex, .ihex.
Supports extended segment address (type 02) and extended linear address (type 04).

.TP
.B srec (Motorola S-record)
Motorola S-record format with embedded addresses. Extensions: .srec, .s19, .s28, .s37, .mot.
Supports S1 (16-bit), S2 (24-bit), and S3 (32-bit) address records.

.SS Address Handling
When using Intel HEX or S-record files that contain address information:
.IP \(bu 4
If \fB-a\fR is omitted, the address from the file is used automatically
.IP \(bu
If \fB-a\fR is specified, it overrides the embedded address
.IP \(bu
Binary files always require \fB-a\fR (defaults to 0x0)

.SS Examples
.nf
radfu write firmware.hex              # Auto-detect Intel HEX, use embedded address
radfu write -f srec app.bin           # Force S-record parsing on .bin file
radfu write -a 0x10000 app.s19        # Override embedded address
radfu write -f bin -a 0x0 data.dat    # Force binary, explicit address
radfu verify firmware.hex             # Verify flash against Intel HEX file
radfu verify -a 0x08000000 app.s19    # Verify at explicit address
.fi

[output formats]
The \fBread\fR command supports multiple output file formats.
Use \fB-F\fR to explicitly specify the format, or let radfu auto-detect from the
file extension.

.SS Supported Formats
.TP
.B binary (bin)
Raw binary data. Extensions: .bin, .dat, or any unknown extension.
No address information included; only raw flash data.

.TP
.B ihex (Intel HEX)
Intel HEX format with extended linear address records (type 04) for addresses
above 64KB. Extensions: .hex, .ihex.

.TP
.B srec (Motorola S-record)
Motorola S-record format with S0 header, S3 data records (32-bit addresses),
and S7 end record. Extensions: .srec, .s19, .s28, .s37, .mot.

.SS Examples
.nf
radfu read -a 0x0 -s 0x10000 firmware.hex    # Auto-detect Intel HEX output
radfu read -a 0x0 -s 0x10000 -F srec out.dat # Force S-record format
radfu read -a 0x08000000 -s 0x2000 data.bin  # Binary output
.fi

[area selection]
The \fB--area\fR option selects a memory area by type instead of requiring
explicit address and size. This simplifies operations on data flash or config
areas where addresses differ between MCU variants.

.SS Area Types
.TP
.B code
User/code flash area (KOA=0x00). The primary firmware storage area.
Typically starts at 0x00000000.
.TP
.B data
Data flash area (KOA=0x10). Non-volatile storage for application data.
Typically starts at 0x08000000.
.TP
.B config
Configuration area (KOA=0x20). Contains block protection settings,
boot flags, and other device configuration. Read-only for most operations.

.SS Usage
When \fB--area\fR is specified, the address and size are automatically
determined from the device's area information response. You can still use
\fB-a\fR and \fB-s\fR to override the defaults.

.SS Examples
.nf
radfu read --area data data.bin           # Read entire data flash
radfu erase --area data                   # Erase data flash
radfu blank-check --area data             # Check data flash is erased
radfu crc --area config                   # CRC of config area
radfu write --area data eeprom.bin        # Write to data flash
.fi

[usb vs uart]
RA microcontrollers support two communication interfaces for the ROM bootloader:

.SS USB Mode (Default)
Connect directly to the MCU's USB peripheral (e.g., J11 on EK-RA4M2).
The device appears as a Renesas USB device (VID 045B:PID 0261).

.IP \(bu 4
Fastest option (~3 seconds for full test suite on RA4M2)
.IP \(bu
Auto-detected by radfu (no \fB-p\fR option needed)
.IP \(bu
Baud rate settings are ignored (USB handles flow control)
.IP \(bu
Requires MCU with USB peripheral

.SS UART Mode (-u option)
Connect via external USB-UART adapter (FTDI, CH340, CP2102, etc.) to the
MCU's SCI pins (P109/P110 on RA4M2).

.IP \(bu 4
Requires \fB-u\fR flag and explicit port: \fBradfu -u -p /dev/ttyUSB0 info\fR
.IP \(bu
Slower than USB (~10 seconds for test suite at 1.5 Mbps)
.IP \(bu
Use \fB-b\fR to set baud rate (auto-detects adapter max rate)
.IP \(bu
Works with any RA MCU (no USB peripheral required)
.IP \(bu
Useful for custom boards without USB connector

.SS When to Use Each Mode
.TS
l l.
Use USB when:	Use UART when:
_
MCU has USB peripheral	MCU lacks USB peripheral
Dev board has USB connector	Custom board with SCI only
Maximum speed needed	USB not available
.TE

[dlm states]
Device Lifecycle Management (DLM) controls the security state of the MCU.
Use \fBradfu dlm\fR to query and \fBradfu dlm-transit <state>\fR to change states.

.SS DLM States and Transit Values
.TP
.B ssd \fR- Secure Software Development
Factory default state. Full access to all features. ID authentication
disabled. Firmware can be freely read/written.

.TP
.B nsecsd \fR- Non-Secure Software Development
TrustZone development state. Secure and non-secure regions configured.
Debug access available.

.TP
.B dpl \fR- Deployed
Production state. Debug access restricted. ID authentication may be
required. Intended for deployed products.

.TP
.B lck_dbg \fR- Locked Debug
Debug interface permanently disabled. Cannot be reversed.
\fBWARNING:\fR This is irreversible.

.TP
.B lck_boot \fR- Locked Boot
Boot interface permanently disabled. Device cannot be reprogrammed
via bootloader. \fBWARNING:\fR This is irreversible and bricks the device
for bootloader access.

.SS State Transitions
.nf
    ssd --> nsecsd --> dpl --> lck_dbg --> lck_boot
     |                  |
     +---> dpl ---------+
.fi

State transitions are one-way. Once a device moves to a more restricted
state, it cannot return to a less restricted state. The \fBinit\fR command
can reset a device to SSD state only if the device supports it and is not
in a locked state.

.SS DLM State Transition Examples

Forward transition (locking):
.nf
    $ radfu dlm-transit dpl
    DLM state transition: SSD (0x02) -> DPL (0x04)
    DLM transit complete: SSD -> DPL
.fi

Authenticated regression (unlocking without erase):
.nf
    $ radfu dlm-auth nsecsd hex:000102030405060708090A0B0C0D0E0F
    DLM state transition: DPL (0x04) -> NSECSD (0x03)
    Authenticating with NONSECDBG_KEY...
    Received challenge: 1A2B3C4D5E6F7A8B9C0D1E2F3A4B5C6D
    Computed response: 8F7E6D5C4B3A2918F7E6D5C4B3A29180...
    DLM authentication successful: DPL -> NSECSD
.fi

Factory reset (erases flash):
.nf
    $ radfu init
    DLM state transition: DPL (0x04) -> SSD (0x02)
    Initializing device (factory reset)...
    WARNING: This will erase all flash areas and reset boundaries!
    Initialize complete: DPL -> SSD
.fi

.SS Command Summary
.nf
radfu dlm                      # Show current DLM state
radfu dlm-transit ssd          # Transition to SSD (from CM only)
radfu dlm-transit nsecsd       # Transition to NSECSD
radfu dlm-transit dpl          # Transition to Deployed
radfu dlm-transit lck_dbg      # Lock debug (IRREVERSIBLE)
radfu dlm-transit lck_boot     # Lock boot interface (IRREVERSIBLE)
radfu dlm-auth ssd file:key    # Regress NSECSD -> SSD (SECDBG_KEY)
radfu dlm-auth nsecsd hex:...  # Regress DPL -> NSECSD (NONSECDBG_KEY)
radfu dlm-auth rma_req file:k  # Enter RMA (erases flash!)
radfu init                     # Factory reset to SSD (erases flash)
.fi

[examples]
.nf
radfu info
radfu read -a 0x0 -s 0x10000 firmware.bin
radfu read -a 0x0 -s 0x10000 firmware.hex        # Intel HEX output
radfu read -a 0x0 -s 0x10000 -F srec firmware.s19  # S-record output
radfu write -b 1000000 -a 0x0 -v firmware.bin
radfu verify -a 0x0 firmware.bin
radfu erase -a 0x0 -s 0x10000
radfu blank-check -a 0x0 -s 0x10000
radfu crc -a 0x0 -s 0x10000
radfu backup device_backup.hex
radfu backup device_backup.srec
radfu restore device_backup.hex
radfu restore -v device_backup.hex
radfu osis
radfu config-read
radfu boundary-set --cfs1 0 --cfs2 0 --dfs 0 --srs1 0 --srs2 0
radfu boundary-set --file zephyr.rpd    # Load from .rpd file
radfu -u -p /dev/ttyUSB0 info    # UART via USB-UART adapter
radfu write -q firmware.bin      # Write without progress bar
radfu raw 0x3A                   # Raw protocol exploration
radfu raw 0x3B 0x00              # Area info with data byte
.fi

[progress display]
During read, write, verify, and blank-check operations, radfu displays a progress
bar with transfer speed and estimated time remaining:

.nf
Writing: [###############...............] 50% (32768/65536) 125.3 KB/s ETA 2s
.fi

The \fB-q\fR (\fB--quiet\fR) option suppresses progress output. This is useful
for scripting or when running operations in the background.

[boundary file support]
The \fBboundary-set\fR command can load TrustZone boundary settings from
a Renesas Partition Data (.rpd) file using \fB--file\fR. This format is
generated by e2studio, Zephyr, and other toolchains.

.SS RPD File Format
The .rpd file is a text file with key=value pairs:

.nf
FLASH_S_SIZE=0x8000      # Secure code flash (bytes) -> CFS1
FLASH_C_SIZE=0x10000     # Code flash with NSC (bytes) -> CFS2
DATA_FLASH_S_SIZE=0x1000 # Secure data flash (bytes) -> DFS
RAM_S_SIZE=0x4000        # Secure SRAM (bytes) -> SRS1
RAM_C_SIZE=0x8000        # SRAM with NSC (bytes) -> SRS2
.fi

Values are in bytes with 0x prefix and automatically converted to KB.

.SS Example
.nf
radfu boundary-set --file build/zephyr/zephyr.rpd
Loaded boundary settings from build/zephyr/zephyr.rpd:
  CFS1: 32 KB, CFS2: 64 KB, DFS: 8 KB
  SRS1: 16 KB, SRS2: 32 KB
Boundary settings stored successfully
.fi

[warnings]
.B USE AT YOUR OWN RISK

This software is provided "as is" without warranty of any kind. The authors
and contributors are not responsible for any damage to your hardware,
bricked devices, or data loss resulting from the use of this tool.

.IP \(bu 4
Always verify you have a backup of important firmware before erasing
.IP \(bu
Double-check addresses and sizes before write or erase operations
.IP \(bu
Ensure stable power supply during flash operations
.IP \(bu
This tool is not officially supported by Renesas

[see also]
.TP
.B Project homepage
https://github.com/vjardin/radfu

.TP
.B Renesas documentation
R01AN5372 - Renesas RA Family System Specifications for Standard Boot Firmware
